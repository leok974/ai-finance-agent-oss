## Multi-stage: build frontend assets then produce hardened edge image

FROM node:20-alpine AS webbuild
## Build metadata args (injected by outer build):
ARG WEB_BRANCH=unknown
ARG WEB_COMMIT=unknown
ARG WEB_BUILD_ID=not_set
ARG VITE_SUGGESTIONS_ENABLED=0
ARG VITE_ANALYTICS_ENABLED=0
ARG VITE_API_BASE=/api
ARG VITE_GIT_BRANCH=unknown
ARG VITE_GIT_COMMIT=unknown
ARG GIT_BRANCH=unknown
ARG GIT_COMMIT=unknown
ARG BUILD_ID=not_set
ARG VITE_ENABLE_LOCAL_AUTH=0
ARG VITE_ENABLE_GOOGLE_OAUTH=1
ARG VITE_ENABLE_GITHUB_OAUTH=0
WORKDIR /w
# Copy only manifest files first for dependency install.
COPY apps/web/package.json apps/web/pnpm-lock.yaml* ./apps/web/
WORKDIR /w/apps/web
RUN corepack enable && corepack prepare pnpm@latest --activate \
	&& pnpm install --frozen-lockfile

# Copy source (exclude node_modules via .dockerignore); copy only dirs needed for build
COPY apps/web/src ./src
COPY apps/web/index.html ./
COPY apps/web/chat ./chat
COPY apps/web/tsconfig*.json ./
COPY apps/web/vite.config.ts ./
COPY apps/web/vitest.config.ts ./
COPY apps/web/tailwind.config.* ./
COPY apps/web/postcss.config.js ./
COPY apps/web/components.json ./
COPY apps/web/public ./public
COPY apps/web/scripts ./scripts

# Expose build metadata to the Vite build via env and a JSON stamp consumed by the app
ENV WEB_BRANCH=${WEB_BRANCH} \
	WEB_COMMIT=${WEB_COMMIT} \
	WEB_BUILD_ID=${WEB_BUILD_ID} \
	RESPECT_EXISTING_STAMP=1 \
	VITE_SUGGESTIONS_ENABLED=${VITE_SUGGESTIONS_ENABLED} \
	VITE_ANALYTICS_ENABLED=${VITE_ANALYTICS_ENABLED} \
	VITE_API_BASE=${VITE_API_BASE} \
	VITE_GIT_BRANCH=${VITE_GIT_BRANCH} \
	VITE_GIT_COMMIT=${VITE_GIT_COMMIT} \
	GIT_BRANCH=${GIT_BRANCH} \
	GIT_COMMIT=${GIT_COMMIT} \
	BUILD_ID=${BUILD_ID} \
	VITE_ENABLE_LOCAL_AUTH=${VITE_ENABLE_LOCAL_AUTH} \
	VITE_ENABLE_GOOGLE_OAUTH=${VITE_ENABLE_GOOGLE_OAUTH} \
	VITE_ENABLE_GITHUB_OAUTH=${VITE_ENABLE_GITHUB_OAUTH}

# Create a build-stamp file (must occur after src copied so it lands inside src/) then build
# If a build-stamp already exists (from repo or host build), keep it; otherwise generate one
RUN if [ -f src/build-stamp.json ]; then echo "[webbuild] using existing src/build-stamp.json"; else node scripts/build-stamp.mjs; fi \
 && pnpm build \
 && mkdir -p dist \
 && cp src/build-stamp.json dist/build.json \
 && node -e "const fs=require('fs');const s=JSON.parse(fs.readFileSync('src/build-stamp.json','utf8'));const v={commit:s.commit,built_at:s.ts,build_id:s.buildId,branch:s.branch};fs.writeFileSync('dist/version.json',JSON.stringify(v,null,2));"

FROM nginx:1.27-alpine
ARG EDGE_GIT_COMMIT=unknown
ARG EDGE_BUILD_TIME=unknown

# Install openssl for CSP hash rendering at container start
RUN apk add --no-cache openssl

# Ensure NGINX can buffer request bodies / proxy temp files
RUN mkdir -p /var/cache/nginx/client_temp /var/cache/nginx/proxy_temp \
 && chown -R nginx:nginx /var/cache/nginx

# Dist assets
COPY --from=webbuild /w/apps/web/dist /usr/share/nginx/html

# Version metadata is generated from the web build stamp and included in dist/version.json

# Copy single authoritative nginx.conf (rendered variant deprecated to avoid drift)
COPY ./deploy/nginx.conf /etc/nginx/nginx.conf
RUN chown -R 101:101 /etc/nginx
RUN rm -f /etc/nginx/conf.d/default.conf 2>/dev/null || true

# Fast-fail asset integrity assertion (runs automatically via nginx official entrypoint)
COPY ./deploy/docker-entrypoint.d /docker-entrypoint.d
# COPY ./nginx/entrypoint.d/10-csp-inline-hashes.sh /docker-entrypoint.d/10-csp-inline-hashes.sh # DISABLED - hangs on startup
COPY ./nginx/entrypoint.d/99-run.sh /docker-entrypoint.d/99-run.sh
COPY ./nginx/conf.d/security-headers.conf /etc/nginx/conf.d/security-headers.conf
RUN chmod +x /docker-entrypoint.d/*.sh
# Runtime CSP hashing only (no build-time pre-render)
